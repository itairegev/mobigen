/**
 * API Client Generator
 *
 * Generates TypeScript API client code for generated mobile apps
 */

import type { TemplateSchema, TableSchema } from '../schemas/types';

export interface GeneratedClient {
  code: string;
  filename: string;
}

/**
 * Generate API client code for a template schema
 */
export function generateApiClient(
  schema: TemplateSchema,
  apiEndpoint: string,
  apiKey: string
): GeneratedClient {
  const entities = schema.tables.map((table) => ({
    name: table.name,
    singularName: singularize(table.name),
    pascalName: toPascalCase(singularize(table.name)),
    attributes: table.attributes,
  }));

  const code = `/**
 * Generated API Client
 *
 * Auto-generated by Mobigen for ${schema.templateId} template
 * DO NOT EDIT - this file will be overwritten
 */

const API_ENDPOINT = '${apiEndpoint}';
const API_KEY = '${apiKey}';

interface RequestOptions {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  path: string;
  body?: Record<string, unknown>;
  params?: Record<string, string>;
}

interface PaginatedResponse<T> {
  items: T[];
  count: number;
  lastKey?: string;
}

class ApiError extends Error {
  constructor(public statusCode: number, message: string) {
    super(message);
    this.name = 'ApiError';
  }
}

async function request<T>(options: RequestOptions): Promise<T> {
  const url = new URL(\`\${API_ENDPOINT}/\${options.path}\`);

  if (options.params) {
    Object.entries(options.params).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });
  }

  const response = await fetch(url.toString(), {
    method: options.method,
    headers: {
      'Content-Type': 'application/json',
      'X-Api-Key': API_KEY,
    },
    body: options.body ? JSON.stringify(options.body) : undefined,
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    throw new ApiError(response.status, error.error || 'Request failed');
  }

  return response.json();
}

// ============================================================
// Type Definitions
// ============================================================

${entities.map((entity) => generateTypeDefinition(entity)).join('\n\n')}

// ============================================================
// API Client
// ============================================================

export const api = {
${entities.map((entity) => generateEntityApi(entity)).join(',\n\n')}
};

export default api;
`;

  return {
    code,
    filename: 'api.ts',
  };
}

function generateTypeDefinition(entity: {
  name: string;
  singularName: string;
  pascalName: string;
  attributes: TableSchema['attributes'];
}): string {
  const typeFields = entity.attributes
    .filter((attr) => !['pk', 'sk'].includes(attr.name))
    .map((attr) => {
      const tsType = mapAttributeType(attr.type);
      const optional = !attr.required ? '?' : '';
      return `  ${attr.name}${optional}: ${tsType};`;
    })
    .join('\n');

  return `export interface ${entity.pascalName} {
  id: string;
${typeFields}
  createdAt: string;
  updatedAt: string;
}

export type Create${entity.pascalName}Input = Omit<${entity.pascalName}, 'id' | 'createdAt' | 'updatedAt'> & { id?: string };
export type Update${entity.pascalName}Input = Partial<Omit<${entity.pascalName}, 'id' | 'createdAt' | 'updatedAt'>>;`;
}

function generateEntityApi(entity: {
  name: string;
  singularName: string;
  pascalName: string;
}): string {
  return `  ${entity.name}: {
    /**
     * List all ${entity.name}
     */
    list: async (options?: { limit?: number; startKey?: string }): Promise<PaginatedResponse<${entity.pascalName}>> => {
      const params: Record<string, string> = {};
      if (options?.limit) params.limit = String(options.limit);
      if (options?.startKey) params.startKey = options.startKey;

      return request({ method: 'GET', path: '${entity.name}', params });
    },

    /**
     * Get a single ${entity.singularName} by ID
     */
    get: async (id: string): Promise<${entity.pascalName}> => {
      return request({ method: 'GET', path: \`${entity.name}/\${id}\` });
    },

    /**
     * Create a new ${entity.singularName}
     */
    create: async (data: Create${entity.pascalName}Input): Promise<${entity.pascalName}> => {
      return request({ method: 'POST', path: '${entity.name}', body: data });
    },

    /**
     * Update an existing ${entity.singularName}
     */
    update: async (id: string, data: Update${entity.pascalName}Input): Promise<${entity.pascalName}> => {
      return request({ method: 'PUT', path: \`${entity.name}/\${id}\`, body: data });
    },

    /**
     * Delete a ${entity.singularName}
     */
    delete: async (id: string): Promise<{ deleted: boolean; id: string }> => {
      return request({ method: 'DELETE', path: \`${entity.name}/\${id}\` });
    },
  }`;
}

function mapAttributeType(type: string): string {
  switch (type) {
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'list':
      return 'unknown[]';
    case 'map':
      return 'Record<string, unknown>';
    default:
      return 'unknown';
  }
}

function singularize(word: string): string {
  if (word.endsWith('ies')) {
    return word.slice(0, -3) + 'y';
  }
  if (word.endsWith('s')) {
    return word.slice(0, -1);
  }
  return word;
}

function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
