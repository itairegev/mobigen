// Firebase Firestore service template
// Auto-generated by Mobigen Firebase Connector

import type { CodeGenContext } from '@mobigen/connectors/core';

export function firebaseFirestoreTemplate(ctx: CodeGenContext): string {
  return `/**
 * Firebase Firestore Service
 * Auto-generated for ${ctx.projectConfig.appName}
 *
 * Provides generic CRUD operations for Firestore.
 * Includes real-time listeners and offline support.
 */

import firestore, { FirebaseFirestoreTypes } from '@react-native-firebase/firestore';
import type { FirestoreError } from '../types/firebase';

/**
 * Generic Firestore service for CRUD operations
 */
export class FirestoreService<T = any> {
  private collectionPath: string;

  constructor(collectionPath: string) {
    this.collectionPath = collectionPath;
  }

  /**
   * Get collection reference
   */
  private getCollection(): FirebaseFirestoreTypes.CollectionReference {
    return firestore().collection(this.collectionPath);
  }

  /**
   * Create a new document
   */
  async create(data: Partial<T>): Promise<{ id: string; error?: FirestoreError }> {
    try {
      const docRef = await this.getCollection().add({
        ...data,
        createdAt: firestore.FieldValue.serverTimestamp(),
        updatedAt: firestore.FieldValue.serverTimestamp(),
      });

      return { id: docRef.id };
    } catch (error: any) {
      return {
        id: '',
        error: this.mapError(error),
      };
    }
  }

  /**
   * Create or update a document with a specific ID
   */
  async set(
    id: string,
    data: Partial<T>,
    options?: { merge?: boolean }
  ): Promise<{ error?: FirestoreError }> {
    try {
      await this.getCollection()
        .doc(id)
        .set(
          {
            ...data,
            updatedAt: firestore.FieldValue.serverTimestamp(),
          },
          options
        );

      return {};
    } catch (error: any) {
      return {
        error: this.mapError(error),
      };
    }
  }

  /**
   * Get a single document by ID
   */
  async getById(id: string): Promise<{ data: T | null; error?: FirestoreError }> {
    try {
      const doc = await this.getCollection().doc(id).get();

      if (!doc.exists) {
        return { data: null };
      }

      return {
        data: {
          id: doc.id,
          ...doc.data(),
        } as T,
      };
    } catch (error: any) {
      return {
        data: null,
        error: this.mapError(error),
      };
    }
  }

  /**
   * Get all documents in the collection
   */
  async getAll(options?: {
    limit?: number;
    orderBy?: { field: string; direction?: 'asc' | 'desc' };
  }): Promise<{ data: T[]; error?: FirestoreError }> {
    try {
      let query = this.getCollection() as FirebaseFirestoreTypes.Query;

      if (options?.orderBy) {
        query = query.orderBy(options.orderBy.field, options.orderBy.direction || 'asc');
      }

      if (options?.limit) {
        query = query.limit(options.limit);
      }

      const snapshot = await query.get();

      const data = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as T[];

      return { data };
    } catch (error: any) {
      return {
        data: [],
        error: this.mapError(error),
      };
    }
  }

  /**
   * Query documents with conditions
   */
  async query(
    conditions: Array<{
      field: string;
      operator: FirebaseFirestoreTypes.WhereFilterOp;
      value: any;
    }>,
    options?: {
      limit?: number;
      orderBy?: { field: string; direction?: 'asc' | 'desc' };
    }
  ): Promise<{ data: T[]; error?: FirestoreError }> {
    try {
      let query = this.getCollection() as FirebaseFirestoreTypes.Query;

      // Apply where conditions
      conditions.forEach((condition) => {
        query = query.where(condition.field, condition.operator, condition.value);
      });

      // Apply ordering
      if (options?.orderBy) {
        query = query.orderBy(options.orderBy.field, options.orderBy.direction || 'asc');
      }

      // Apply limit
      if (options?.limit) {
        query = query.limit(options.limit);
      }

      const snapshot = await query.get();

      const data = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as T[];

      return { data };
    } catch (error: any) {
      return {
        data: [],
        error: this.mapError(error),
      };
    }
  }

  /**
   * Update a document
   */
  async update(id: string, data: Partial<T>): Promise<{ error?: FirestoreError }> {
    try {
      await this.getCollection()
        .doc(id)
        .update({
          ...data,
          updatedAt: firestore.FieldValue.serverTimestamp(),
        });

      return {};
    } catch (error: any) {
      return {
        error: this.mapError(error),
      };
    }
  }

  /**
   * Delete a document
   */
  async delete(id: string): Promise<{ error?: FirestoreError }> {
    try {
      await this.getCollection().doc(id).delete();
      return {};
    } catch (error: any) {
      return {
        error: this.mapError(error),
      };
    }
  }

  /**
   * Subscribe to a single document
   */
  onDocumentSnapshot(
    id: string,
    callback: (data: T | null, error?: FirestoreError) => void
  ): () => void {
    return this.getCollection()
      .doc(id)
      .onSnapshot(
        (doc) => {
          if (!doc.exists) {
            callback(null);
            return;
          }

          callback({
            id: doc.id,
            ...doc.data(),
          } as T);
        },
        (error) => {
          callback(null, this.mapError(error));
        }
      );
  }

  /**
   * Subscribe to collection changes
   */
  onCollectionSnapshot(
    callback: (data: T[], error?: FirestoreError) => void,
    options?: {
      limit?: number;
      orderBy?: { field: string; direction?: 'asc' | 'desc' };
    }
  ): () => void {
    let query = this.getCollection() as FirebaseFirestoreTypes.Query;

    if (options?.orderBy) {
      query = query.orderBy(options.orderBy.field, options.orderBy.direction || 'asc');
    }

    if (options?.limit) {
      query = query.limit(options.limit);
    }

    return query.onSnapshot(
      (snapshot) => {
        const data = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as T[];

        callback(data);
      },
      (error) => {
        callback([], this.mapError(error));
      }
    );
  }

  /**
   * Subscribe to query results
   */
  onQuerySnapshot(
    conditions: Array<{
      field: string;
      operator: FirebaseFirestoreTypes.WhereFilterOp;
      value: any;
    }>,
    callback: (data: T[], error?: FirestoreError) => void,
    options?: {
      limit?: number;
      orderBy?: { field: string; direction?: 'asc' | 'desc' };
    }
  ): () => void {
    let query = this.getCollection() as FirebaseFirestoreTypes.Query;

    // Apply where conditions
    conditions.forEach((condition) => {
      query = query.where(condition.field, condition.operator, condition.value);
    });

    // Apply ordering
    if (options?.orderBy) {
      query = query.orderBy(options.orderBy.field, options.orderBy.direction || 'asc');
    }

    // Apply limit
    if (options?.limit) {
      query = query.limit(options.limit);
    }

    return query.onSnapshot(
      (snapshot) => {
        const data = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as T[];

        callback(data);
      },
      (error) => {
        callback([], this.mapError(error));
      }
    );
  }

  /**
   * Batch write operations
   */
  async batchWrite(
    operations: Array<
      | { type: 'set'; id: string; data: Partial<T> }
      | { type: 'update'; id: string; data: Partial<T> }
      | { type: 'delete'; id: string }
    >
  ): Promise<{ error?: FirestoreError }> {
    try {
      const batch = firestore().batch();

      operations.forEach((operation) => {
        const docRef = this.getCollection().doc(operation.id);

        if (operation.type === 'set') {
          batch.set(docRef, {
            ...operation.data,
            updatedAt: firestore.FieldValue.serverTimestamp(),
          });
        } else if (operation.type === 'update') {
          batch.update(docRef, {
            ...operation.data,
            updatedAt: firestore.FieldValue.serverTimestamp(),
          });
        } else if (operation.type === 'delete') {
          batch.delete(docRef);
        }
      });

      await batch.commit();
      return {};
    } catch (error: any) {
      return {
        error: this.mapError(error),
      };
    }
  }

  /**
   * Run a transaction
   */
  async runTransaction<R>(
    updateFunction: (transaction: FirebaseFirestoreTypes.Transaction) => Promise<R>
  ): Promise<{ result?: R; error?: FirestoreError }> {
    try {
      const result = await firestore().runTransaction(updateFunction);
      return { result };
    } catch (error: any) {
      return {
        error: this.mapError(error),
      };
    }
  }

  /**
   * Map Firestore error to our error type
   */
  private mapError(error: any): FirestoreError {
    return {
      code: error.code || 'unknown',
      message: error.message || 'An unknown error occurred',
      originalError: error,
    };
  }
}

// Export commonly used field values
export const FieldValue = {
  serverTimestamp: () => firestore.FieldValue.serverTimestamp(),
  delete: () => firestore.FieldValue.delete(),
  increment: (n: number) => firestore.FieldValue.increment(n),
  arrayUnion: (...elements: any[]) => firestore.FieldValue.arrayUnion(...elements),
  arrayRemove: (...elements: any[]) => firestore.FieldValue.arrayRemove(...elements),
};

// Export Firestore instance
export { firestore };
`;
}
