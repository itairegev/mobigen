// Firebase Firestore hooks template
// Auto-generated by Mobigen Firebase Connector

import type { CodeGenContext } from '@mobigen/connectors/core';

export function useFirestoreTemplate(ctx: CodeGenContext): string {
  return `/**
 * Firestore React Hooks
 * Auto-generated for ${ctx.projectConfig.appName}
 *
 * Provides React hooks for Firestore operations.
 * Includes real-time data synchronization and automatic cleanup.
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { FirebaseFirestoreTypes } from '@react-native-firebase/firestore';
import { FirestoreService } from '../services/firebase-firestore';
import type { FirestoreError } from '../types/firebase';

/**
 * Hook for reading a single document with real-time updates
 */
export function useDocument<T = any>(collectionPath: string, documentId: string | null) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  useEffect(() => {
    if (!documentId) {
      setData(null);
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    // Subscribe to real-time updates
    const unsubscribe = serviceRef.current.onDocumentSnapshot(
      documentId,
      (docData, docError) => {
        setData(docData);
        setError(docError || null);
        setLoading(false);
      }
    );

    // Cleanup subscription on unmount
    return () => unsubscribe();
  }, [collectionPath, documentId]);

  return {
    data,
    loading,
    error,
  };
}

/**
 * Hook for reading a collection with real-time updates
 */
export function useCollection<T = any>(
  collectionPath: string,
  options?: {
    limit?: number;
    orderBy?: { field: string; direction?: 'asc' | 'desc' };
  }
) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  useEffect(() => {
    setLoading(true);
    setError(null);

    // Subscribe to real-time updates
    const unsubscribe = serviceRef.current.onCollectionSnapshot(
      (collectionData, collectionError) => {
        setData(collectionData);
        setError(collectionError || null);
        setLoading(false);
      },
      options
    );

    // Cleanup subscription on unmount
    return () => unsubscribe();
  }, [collectionPath, JSON.stringify(options)]);

  return {
    data,
    loading,
    error,
  };
}

/**
 * Hook for querying documents with real-time updates
 */
export function useQuery<T = any>(
  collectionPath: string,
  conditions: Array<{
    field: string;
    operator: FirebaseFirestoreTypes.WhereFilterOp;
    value: any;
  }>,
  options?: {
    limit?: number;
    orderBy?: { field: string; direction?: 'asc' | 'desc' };
  }
) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  useEffect(() => {
    setLoading(true);
    setError(null);

    // Subscribe to real-time updates
    const unsubscribe = serviceRef.current.onQuerySnapshot(
      conditions,
      (queryData, queryError) => {
        setData(queryData);
        setError(queryError || null);
        setLoading(false);
      },
      options
    );

    // Cleanup subscription on unmount
    return () => unsubscribe();
  }, [collectionPath, JSON.stringify(conditions), JSON.stringify(options)]);

  return {
    data,
    loading,
    error,
  };
}

/**
 * Hook for creating documents
 */
export function useCreateDocument<T = any>(collectionPath: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  const create = useCallback(
    async (data: Partial<T>) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.create(data);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true, id: result.id };
      } catch (err: any) {
        const firestoreError: FirestoreError = {
          code: 'unknown',
          message: err.message || 'Failed to create document',
          originalError: err,
        };
        setError(firestoreError);
        return { success: false, error: firestoreError };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  return {
    create,
    loading,
    error,
  };
}

/**
 * Hook for updating documents
 */
export function useUpdateDocument<T = any>(collectionPath: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  const update = useCallback(
    async (id: string, data: Partial<T>) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.update(id, data);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true };
      } catch (err: any) {
        const firestoreError: FirestoreError = {
          code: 'unknown',
          message: err.message || 'Failed to update document',
          originalError: err,
        };
        setError(firestoreError);
        return { success: false, error: firestoreError };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  return {
    update,
    loading,
    error,
  };
}

/**
 * Hook for deleting documents
 */
export function useDeleteDocument<T = any>(collectionPath: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  const deleteDoc = useCallback(
    async (id: string) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.delete(id);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true };
      } catch (err: any) {
        const firestoreError: FirestoreError = {
          code: 'unknown',
          message: err.message || 'Failed to delete document',
          originalError: err,
        };
        setError(firestoreError);
        return { success: false, error: firestoreError };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  return {
    delete: deleteDoc,
    loading,
    error,
  };
}

/**
 * Hook for batch mutations (create, update, delete)
 */
export function useMutation<T = any>(collectionPath: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<FirestoreError | null>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  const create = useCallback(
    async (data: Partial<T>) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.create(data);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true, id: result.id };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  const update = useCallback(
    async (id: string, data: Partial<T>) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.update(id, data);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  const deleteDoc = useCallback(
    async (id: string) => {
      setLoading(true);
      setError(null);

      try {
        const result = await serviceRef.current.delete(id);

        if (result.error) {
          setError(result.error);
          return { success: false, error: result.error };
        }

        return { success: true };
      } finally {
        setLoading(false);
      }
    },
    [collectionPath]
  );

  return {
    create,
    update,
    delete: deleteDoc,
    loading,
    error,
  };
}

/**
 * Hook for paginated queries
 */
export function usePaginatedQuery<T = any>(
  collectionPath: string,
  pageSize: number = 10,
  orderByField: string = 'createdAt',
  orderDirection: 'asc' | 'desc' = 'desc'
) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<FirestoreError | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [lastDoc, setLastDoc] = useState<any>(null);

  const serviceRef = useRef(new FirestoreService<T>(collectionPath));

  const loadMore = useCallback(async () => {
    if (!hasMore || loading) return;

    setLoading(true);
    setError(null);

    try {
      const result = await serviceRef.current.getAll({
        limit: pageSize,
        orderBy: { field: orderByField, direction: orderDirection },
      });

      if (result.error) {
        setError(result.error);
        return;
      }

      if (result.data.length < pageSize) {
        setHasMore(false);
      }

      if (result.data.length > 0) {
        setLastDoc(result.data[result.data.length - 1]);
        setData((prev) => [...prev, ...result.data]);
      }
    } catch (err: any) {
      const firestoreError: FirestoreError = {
        code: 'unknown',
        message: err.message || 'Failed to load more',
        originalError: err,
      };
      setError(firestoreError);
    } finally {
      setLoading(false);
    }
  }, [collectionPath, pageSize, orderByField, orderDirection, hasMore, loading, lastDoc]);

  const reset = useCallback(() => {
    setData([]);
    setLastDoc(null);
    setHasMore(true);
    setError(null);
  }, []);

  // Load initial page
  useEffect(() => {
    loadMore();
  }, [collectionPath]);

  return {
    data,
    loading,
    error,
    hasMore,
    loadMore,
    reset,
  };
}
`;
}
