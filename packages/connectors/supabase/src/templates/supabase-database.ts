/**
 * Supabase Database Service Template
 *
 * Generates database query functions with type safety
 */

import type { CodeGenContext } from '@mobigen/connectors-core/types';

export function supabaseDatabaseTemplate(ctx: CodeGenContext): string {
  return `/**
 * Supabase Database Service
 *
 * Auto-generated by Mobigen Supabase Connector
 * Provides type-safe database operations and real-time subscriptions
 */

import { supabase } from './supabase-client';
import type { PostgrestError, RealtimeChannel } from '@supabase/supabase-js';

/**
 * Generic table query helper with type safety
 *
 * @param tableName - Name of the table
 * @returns Query builder
 *
 * @example
 * ```typescript
 * // Fetch all products
 * const { data, error } = await from<Product>('products').select('*');
 *
 * // Fetch with filters
 * const { data } = await from<Product>('products')
 *   .select('*')
 *   .eq('category', 'electronics')
 *   .order('created_at', { ascending: false });
 * ```
 */
export function from<T = any>(tableName: string) {
  return supabase.from(tableName);
}

/**
 * Insert a single record
 *
 * @param tableName - Name of the table
 * @param data - Record to insert
 * @returns Inserted record
 *
 * @example
 * ```typescript
 * const newProduct = await insert('products', {
 *   name: 'iPhone 15',
 *   price: 999,
 *   category: 'electronics',
 * });
 * ```
 */
export async function insert<T = any>(
  tableName: string,
  data: Partial<T>
): Promise<{ data: T | null; error: PostgrestError | null }> {
  const { data: result, error } = await supabase
    .from(tableName)
    .insert(data)
    .select()
    .single();

  return { data: result as T | null, error };
}

/**
 * Insert multiple records
 *
 * @param tableName - Name of the table
 * @param data - Array of records to insert
 * @returns Inserted records
 */
export async function insertMany<T = any>(
  tableName: string,
  data: Partial<T>[]
): Promise<{ data: T[] | null; error: PostgrestError | null }> {
  const { data: result, error } = await supabase
    .from(tableName)
    .insert(data)
    .select();

  return { data: result as T[] | null, error };
}

/**
 * Update records matching filter
 *
 * @param tableName - Name of the table
 * @param filter - Filter criteria
 * @param data - Data to update
 * @returns Updated records
 *
 * @example
 * ```typescript
 * const { data } = await update('products', { id: '123' }, {
 *   price: 899,
 *   stock: 50,
 * });
 * ```
 */
export async function update<T = any>(
  tableName: string,
  filter: Record<string, any>,
  data: Partial<T>
): Promise<{ data: T[] | null; error: PostgrestError | null }> {
  let query = supabase.from(tableName).update(data);

  // Apply filters
  Object.entries(filter).forEach(([key, value]) => {
    query = query.eq(key, value);
  });

  const { data: result, error } = await query.select();

  return { data: result as T[] | null, error };
}

/**
 * Delete records matching filter
 *
 * @param tableName - Name of the table
 * @param filter - Filter criteria
 * @returns Deleted records
 *
 * @example
 * ```typescript
 * await deleteRecords('products', { id: '123' });
 * ```
 */
export async function deleteRecords<T = any>(
  tableName: string,
  filter: Record<string, any>
): Promise<{ data: T[] | null; error: PostgrestError | null }> {
  let query = supabase.from(tableName).delete();

  // Apply filters
  Object.entries(filter).forEach(([key, value]) => {
    query = query.eq(key, value);
  });

  const { data: result, error } = await query.select();

  return { data: result as T[] | null, error };
}

/**
 * Fetch records with pagination
 *
 * @param tableName - Name of the table
 * @param options - Pagination and filter options
 * @returns Paginated results
 *
 * @example
 * ```typescript
 * const { data, count } = await paginate('products', {
 *   page: 1,
 *   pageSize: 20,
 *   orderBy: 'created_at',
 *   ascending: false,
 *   filter: { category: 'electronics' },
 * });
 * ```
 */
export async function paginate<T = any>(
  tableName: string,
  options: {
    page?: number;
    pageSize?: number;
    orderBy?: string;
    ascending?: boolean;
    filter?: Record<string, any>;
  } = {}
): Promise<{ data: T[] | null; count: number | null; error: PostgrestError | null }> {
  const { page = 1, pageSize = 10, orderBy = 'created_at', ascending = false, filter = {} } = options;

  const from = (page - 1) * pageSize;
  const to = from + pageSize - 1;

  let query = supabase.from(tableName).select('*', { count: 'exact' });

  // Apply filters
  Object.entries(filter).forEach(([key, value]) => {
    query = query.eq(key, value);
  });

  // Apply ordering and pagination
  query = query.order(orderBy, { ascending }).range(from, to);

  const { data, count, error } = await query;

  return { data: data as T[] | null, count, error };
}

/**
 * Subscribe to real-time changes on a table
 *
 * @param tableName - Name of the table
 * @param filter - Optional filter criteria
 * @param callbacks - Callbacks for different events
 * @returns Subscription object with unsubscribe method
 *
 * @example
 * ```typescript
 * const subscription = subscribeToTable('products', { category: 'electronics' }, {
 *   onInsert: (newProduct) => console.log('New product:', newProduct),
 *   onUpdate: (updatedProduct) => console.log('Updated:', updatedProduct),
 *   onDelete: (deletedProduct) => console.log('Deleted:', deletedProduct),
 * });
 *
 * // Later: subscription.unsubscribe()
 * ```
 */
export function subscribeToTable<T = any>(
  tableName: string,
  filter: Record<string, any> | null,
  callbacks: {
    onInsert?: (record: T) => void;
    onUpdate?: (record: T) => void;
    onDelete?: (record: T) => void;
  }
): { channel: RealtimeChannel; unsubscribe: () => void } {
  let channel = supabase.channel(\`public:\${tableName}\`);

  // Apply filter if provided
  const filterString = filter
    ? Object.entries(filter)
        .map(([key, value]) => \`\${key}=eq.\${value}\`)
        .join(',')
    : null;

  // Subscribe to INSERT events
  if (callbacks.onInsert) {
    channel = channel.on(
      'postgres_changes',
      {
        event: 'INSERT',
        schema: 'public',
        table: tableName,
        filter: filterString || undefined,
      },
      (payload) => callbacks.onInsert!(payload.new as T)
    );
  }

  // Subscribe to UPDATE events
  if (callbacks.onUpdate) {
    channel = channel.on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: tableName,
        filter: filterString || undefined,
      },
      (payload) => callbacks.onUpdate!(payload.new as T)
    );
  }

  // Subscribe to DELETE events
  if (callbacks.onDelete) {
    channel = channel.on(
      'postgres_changes',
      {
        event: 'DELETE',
        schema: 'public',
        table: tableName,
        filter: filterString || undefined,
      },
      (payload) => callbacks.onDelete!(payload.old as T)
    );
  }

  // Subscribe to the channel
  channel.subscribe();

  return {
    channel,
    unsubscribe: () => {
      supabase.removeChannel(channel);
    },
  };
}

/**
 * Call a Supabase Edge Function
 *
 * @param functionName - Name of the edge function
 * @param payload - Data to send to the function
 * @returns Function response
 *
 * @example
 * ```typescript
 * const { data, error } = await callEdgeFunction('send-email', {
 *   to: 'user@example.com',
 *   subject: 'Welcome!',
 * });
 * ```
 */
export async function callEdgeFunction<T = any>(
  functionName: string,
  payload?: object
): Promise<{ data: T | null; error: any }> {
  try {
    const { data, error } = await supabase.functions.invoke(functionName, {
      body: payload,
    });

    return { data: data as T | null, error };
  } catch (error) {
    return { data: null, error };
  }
}
`;
}
