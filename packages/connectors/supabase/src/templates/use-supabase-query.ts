/**
 * Supabase Query Hooks Template
 *
 * Generates React hooks for database operations with caching
 */

import type { CodeGenContext } from '@mobigen/connectors-core/types';

export function useSupabaseQueryTemplate(ctx: CodeGenContext): string {
  return `/**
 * Supabase Query Hooks
 *
 * Auto-generated by Mobigen Supabase Connector
 * React hooks for database operations with automatic caching and real-time updates
 */

import { useState, useEffect, useCallback } from 'react';
import type { PostgrestError } from '@supabase/supabase-js';
import * as DatabaseService from '../services/supabase-database';

/**
 * Hook for fetching data with caching
 *
 * @param tableName - Name of the table
 * @param options - Query options
 * @returns Query result with loading and error states
 *
 * @example
 * ```typescript
 * function ProductList() {
 *   const { data: products, loading, error, refetch } = useSupabaseQuery('products', {
 *     filter: { category: 'electronics' },
 *     orderBy: 'created_at',
 *     ascending: false,
 *   });
 *
 *   if (loading) return <Loading />;
 *   if (error) return <Error message={error} />;
 *
 *   return (
 *     <div>
 *       {products?.map(product => <ProductCard key={product.id} {...product} />)}
 *     </div>
 *   );
 * }
 * ```
 */
export function useSupabaseQuery<T = any>(
  tableName: string,
  options: {
    filter?: Record<string, any>;
    orderBy?: string;
    ascending?: boolean;
    limit?: number;
    enabled?: boolean;
  } = {}
) {
  const [data, setData] = useState<T[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { filter = {}, orderBy = 'created_at', ascending = false, limit, enabled = true } = options;

  const fetchData = useCallback(async () => {
    if (!enabled) {
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      let query = DatabaseService.from<T>(tableName).select('*');

      // Apply filters
      Object.entries(filter).forEach(([key, value]) => {
        query = query.eq(key, value);
      });

      // Apply ordering
      query = query.order(orderBy, { ascending });

      // Apply limit
      if (limit) {
        query = query.limit(limit);
      }

      const { data: result, error: queryError } = await query;

      if (queryError) {
        setError(queryError.message);
        setData(null);
      } else {
        setData(result as T[]);
      }
    } catch (err: any) {
      setError(err.message || 'Query failed');
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [tableName, JSON.stringify(filter), orderBy, ascending, limit, enabled]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
  };
}

/**
 * Hook for paginated data fetching
 *
 * @param tableName - Name of the table
 * @param options - Pagination options
 * @returns Paginated result with navigation functions
 *
 * @example
 * ```typescript
 * function ProductList() {
 *   const {
 *     data: products,
 *     loading,
 *     page,
 *     totalPages,
 *     nextPage,
 *     prevPage,
 *   } = useSupabasePagination('products', {
 *     pageSize: 20,
 *     orderBy: 'created_at',
 *   });
 *
 *   return (
 *     <div>
 *       {products?.map(product => <ProductCard key={product.id} {...product} />)}
 *       <button onClick={prevPage} disabled={page === 1}>Previous</button>
 *       <button onClick={nextPage} disabled={page === totalPages}>Next</button>
 *     </div>
 *   );
 * }
 * ```
 */
export function useSupabasePagination<T = any>(
  tableName: string,
  options: {
    pageSize?: number;
    orderBy?: string;
    ascending?: boolean;
    filter?: Record<string, any>;
  } = {}
) {
  const [data, setData] = useState<T[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [totalCount, setTotalCount] = useState(0);

  const { pageSize = 10, orderBy = 'created_at', ascending = false, filter = {} } = options;

  const totalPages = Math.ceil(totalCount / pageSize);

  const fetchPage = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const result = await DatabaseService.paginate<T>(tableName, {
        page,
        pageSize,
        orderBy,
        ascending,
        filter,
      });

      if (result.error) {
        setError(result.error.message);
        setData(null);
      } else {
        setData(result.data);
        setTotalCount(result.count || 0);
      }
    } catch (err: any) {
      setError(err.message || 'Pagination failed');
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [tableName, page, pageSize, orderBy, ascending, JSON.stringify(filter)]);

  useEffect(() => {
    fetchPage();
  }, [fetchPage]);

  const nextPage = useCallback(() => {
    if (page < totalPages) {
      setPage((p) => p + 1);
    }
  }, [page, totalPages]);

  const prevPage = useCallback(() => {
    if (page > 1) {
      setPage((p) => p - 1);
    }
  }, [page]);

  const goToPage = useCallback((newPage: number) => {
    if (newPage >= 1 && newPage <= totalPages) {
      setPage(newPage);
    }
  }, [totalPages]);

  return {
    data,
    loading,
    error,
    page,
    totalPages,
    totalCount,
    nextPage,
    prevPage,
    goToPage,
    refetch: fetchPage,
  };
}

/**
 * Hook for database mutations (insert, update, delete)
 *
 * @param tableName - Name of the table
 * @returns Mutation functions with loading states
 *
 * @example
 * ```typescript
 * function ProductForm() {
 *   const { insert, update, remove, loading } = useSupabaseMutation('products');
 *
 *   const handleSave = async (product: Product) => {
 *     const { data } = await insert(product);
 *     if (data) {
 *       console.log('Saved:', data);
 *     }
 *   };
 *
 *   return <form>{/* ... */}</form>;
 * }
 * ```
 */
export function useSupabaseMutation<T = any>(tableName: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const insert = useCallback(async (data: Partial<T>) => {
    setLoading(true);
    setError(null);

    try {
      const result = await DatabaseService.insert<T>(tableName, data);

      if (result.error) {
        setError(result.error.message);
        return { data: null, error: result.error };
      }

      return { data: result.data, error: null };
    } catch (err: any) {
      setError(err.message || 'Insert failed');
      return { data: null, error: err };
    } finally {
      setLoading(false);
    }
  }, [tableName]);

  const insertMany = useCallback(async (data: Partial<T>[]) => {
    setLoading(true);
    setError(null);

    try {
      const result = await DatabaseService.insertMany<T>(tableName, data);

      if (result.error) {
        setError(result.error.message);
        return { data: null, error: result.error };
      }

      return { data: result.data, error: null };
    } catch (err: any) {
      setError(err.message || 'Insert failed');
      return { data: null, error: err };
    } finally {
      setLoading(false);
    }
  }, [tableName]);

  const update = useCallback(async (filter: Record<string, any>, data: Partial<T>) => {
    setLoading(true);
    setError(null);

    try {
      const result = await DatabaseService.update<T>(tableName, filter, data);

      if (result.error) {
        setError(result.error.message);
        return { data: null, error: result.error };
      }

      return { data: result.data, error: null };
    } catch (err: any) {
      setError(err.message || 'Update failed');
      return { data: null, error: err };
    } finally {
      setLoading(false);
    }
  }, [tableName]);

  const remove = useCallback(async (filter: Record<string, any>) => {
    setLoading(true);
    setError(null);

    try {
      const result = await DatabaseService.deleteRecords<T>(tableName, filter);

      if (result.error) {
        setError(result.error.message);
        return { data: null, error: result.error };
      }

      return { data: result.data, error: null };
    } catch (err: any) {
      setError(err.message || 'Delete failed');
      return { data: null, error: err };
    } finally {
      setLoading(false);
    }
  }, [tableName]);

  return {
    insert,
    insertMany,
    update,
    remove,
    loading,
    error,
  };
}

/**
 * Hook for real-time subscriptions
 *
 * @param tableName - Name of the table
 * @param filter - Optional filter criteria
 * @param callbacks - Callbacks for different events
 *
 * @example
 * ```typescript
 * function LiveProductList() {
 *   const [products, setProducts] = useState<Product[]>([]);
 *
 *   useSupabaseRealtime('products', { category: 'electronics' }, {
 *     onInsert: (newProduct) => {
 *       setProducts(prev => [...prev, newProduct]);
 *     },
 *     onUpdate: (updatedProduct) => {
 *       setProducts(prev => prev.map(p =>
 *         p.id === updatedProduct.id ? updatedProduct : p
 *       ));
 *     },
 *     onDelete: (deletedProduct) => {
 *       setProducts(prev => prev.filter(p => p.id !== deletedProduct.id));
 *     },
 *   });
 *
 *   return <div>{products.map(p => <ProductCard key={p.id} {...p} />)}</div>;
 * }
 * ```
 */
export function useSupabaseRealtime<T = any>(
  tableName: string,
  filter: Record<string, any> | null = null,
  callbacks: {
    onInsert?: (record: T) => void;
    onUpdate?: (record: T) => void;
    onDelete?: (record: T) => void;
  }
) {
  useEffect(() => {
    const subscription = DatabaseService.subscribeToTable<T>(tableName, filter, callbacks);

    return () => {
      subscription.unsubscribe();
    };
  }, [tableName, JSON.stringify(filter)]);
}
`;
}
